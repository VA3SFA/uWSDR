/*
 *   Copyright (C) 2006-2007,2013 by Jonathan Naylor G4KLX
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include "CWKeyer.h"

#include "UWSDRApp.h"

const float RC_LEN = 5.0F;			// The length of the raised cosine in ms

const unsigned int SUBDIV = 4U;		// The sub-division of the clock

CCWKeyer::CCWKeyer() :
CThreadReader(),
m_sampleRate(0.0F),
m_blockSize(0U),
m_callback(NULL),
m_id(0),
m_state(CW_STOP),
m_speed(0U),
m_text(),
m_bits(NULL),
m_bitsLen(0U),
m_bitsIndex(0U),
m_key(false),
m_lastKey(false),
m_buffer(NULL),
m_defLen(0U),
m_cosDelta(0.0F),
m_sinDelta(0.0F),
m_cosValue(1.0F),
m_sinValue(0.0F)
{
}

CCWKeyer::~CCWKeyer()
{
	delete[] m_bits;
	delete[] m_buffer;
}

bool CCWKeyer::open(float sampleRate, unsigned int blockSize)
{
	wxASSERT(sampleRate > 0.0F);

	m_sampleRate = sampleRate;
	m_blockSize  = blockSize;

	// Calculate the length of the raised cosine shaping section
	m_defLen = (unsigned int)(RC_LEN * m_sampleRate / 1000.0F + 0.5F);

	float delta = CW_OFFSET / m_sampleRate * 2.0 * M_PI;

	m_cosDelta = ::cos(delta);
	m_sinDelta = ::sin(delta);

	m_buffer = new float[m_blockSize * 2U];

	return CThreadReader::open(sampleRate, blockSize);
}

/*
 * This is called from the "software interrupt" generated by the sound card carrying
 * the microphone audio. It is called once per BLOCK_SIZE samples.
 */
bool CCWKeyer::create()
{
	wxASSERT(m_callback != NULL);

	// Key pressed when transmitting from the CW keyboard, abort
	if (m_key && m_bitsLen > 0U) {
		end();
		return true;
	}

	// Sending a message from the keyboard
	if (m_bitsLen > 0U) {
		// End of the message ?
		if (m_bitsIndex >= m_bitsLen) {
			if (!m_text.IsEmpty()) {
				createCW(m_text, m_speed);
				m_text.Clear();
			} else {
				if (m_state == CW_SEND_TEXT)
					end();
				return true;
			}
		}

		// Send the next set of units, from the bit array
		float* buffer = m_buffer;
		for (unsigned int i = 0U; i < SUBDIV && m_bitsIndex < m_bitsLen; i++) {
			bool key = m_bits[m_bitsIndex++];
			processKey(key, buffer, m_blockSize / SUBDIV);
			buffer += (m_blockSize / SUBDIV) * 2U;
		}

		m_callback->callback(m_buffer, m_blockSize, m_id);

		return true;
	}

	// Use the status of the real key
	processKey(m_key, m_buffer, m_blockSize);

	m_callback->callback(m_buffer, m_blockSize, m_id);

	return true;
}

void CCWKeyer::setCallback(IDataCallback* callback, int id)
{
	m_callback = callback;
	m_id       = id;
}

/*
 * Set the speed in WPM and generate a bit map of the individual blocks with
 * carrier (or not) entries.
 */
CWERROR CCWKeyer::send(unsigned int speed, const wxString& text, CWSTATUS state)
{
	if (state == CW_STOP) {
		end();
		return CW_ERROR_NONE;
	}

	wxASSERT(state == CW_SEND_TEXT || state == CW_SEND_CHAR);

	// We're already sending text, we can't do anything
	if (m_state == CW_SEND_TEXT && m_bitsLen > 0U)
		return CW_ERROR_TX;

	// Already sending real-time so queue the next character
	if (state == CW_SEND_CHAR && m_state == CW_SEND_CHAR && m_bitsLen > 0U) {
		m_text.Append(text);
		return CW_ERROR_NONE;
	}

	if (state == CW_SEND_TEXT) {
		CWERROR ret = ::wxGetApp().sendCW(0U, wxEmptyString, CW_TX_ON);

		if (ret != CW_ERROR_NONE)
			return ret;
	}

	createCW(text, speed);

	m_speed = speed;
	m_state = state;

	return CW_ERROR_NONE;
}

/*
 * Calculate the length of a dot in numbers of blocks, the speed in words per minute.
 * At 12.5 WPM a dot is 1/10 of a second.
 */
unsigned int CCWKeyer::speedToUnits(unsigned int speed)
{
	float sysUnitsPerSec = float(SUBDIV) * m_sampleRate / float(m_blockSize);

	float unitsPerSec = 10.0F * float(speed) / 12.5F;

	unsigned int mult = (unsigned int)(sysUnitsPerSec / unitsPerSec + 0.5F);

	if (mult == 0U)
		return 1U;

	return mult;
}

void CCWKeyer::end()
{
	m_bitsLen   = 0U;
	m_bitsIndex = 0U;

	delete[] m_bits;
	m_bits = NULL;

	m_text.Clear();

	::wxGetApp().sendCW(0U, wxEmptyString, CW_TX_OFF);

	m_state = CW_STOP;
}

bool CCWKeyer::isActive() const
{
	return true;
}

void CCWKeyer::key(bool keyDown)
{
	m_key = keyDown;
}

void CCWKeyer::createCW(const wxString& text, unsigned int speed)
{
	m_bitsLen   = 0U;
	m_bitsIndex = 0U;

	delete[] m_bits;
	m_bits = NULL;

	unsigned int textLen = text.Length();

	if (textLen == 0U)
		return;

	unsigned int mult = speedToUnits(speed);

	// Quick and dirty maximum length calculation
	unsigned int bitsLen = textLen * 4U * mult;

	m_bits = new bool[bitsLen];

	bitsLen = 0U;

	unsigned int j;
	for (unsigned int i = 0U; i < textLen; i++) {
		wxChar c = text.GetChar(i);

		switch (c) {
			case wxT('.'):
				for (j = 0U; j < 1U * mult; j++)
					m_bits[bitsLen++] = true;
				break;

			case wxT('-'):
				for (j = 0U; j < 3U * mult; j++)
					m_bits[bitsLen++] = true;
				break;

			case wxT(' '):
				for (j = 0U; j < 1U * mult; j++)
					m_bits[bitsLen++] = false;
				break;
		}

		for (j = 0U; j < 1U * mult; j++)
			m_bits[bitsLen++] = false;
	}

	m_bitsLen   = bitsLen;
	m_bitsIndex = 0U;
}

void CCWKeyer::processKey(bool key, float* buffer, unsigned int blockSize)
{
	wxASSERT(buffer != NULL);

	// Generate silence
	if (!key && !m_lastKey) {
		::memset(buffer, 0x00, blockSize * 2U * sizeof(float));
		return;
	}

	// Reset the phase if beginning a symbol
	if (key && !m_lastKey) {
		m_cosValue = 1.0F;
		m_sinValue = 0.0F;
	}

	// Generate a continuous tone, phase contiguous with the previous one
	for (unsigned int i = 0; i < blockSize; i++) {
		float tmpValue = m_cosValue * m_cosDelta - m_sinValue * m_sinDelta;
		m_sinValue = m_cosValue * m_sinDelta + m_sinValue * m_cosDelta;
		m_cosValue = tmpValue;

		buffer[i * 2U + 0U] = m_sinValue;
		buffer[i * 2U + 1U] = m_sinValue;
	}

	// Continuous tone
	if (key && m_lastKey)
		return;

	// Start of a tone, shape the beginning
	if (key && !m_lastKey) {
		for (unsigned int i = 0U; i < m_defLen; i++) {
			float ampl = 0.5F * (1.0F - ::cos(M_PI * (float(i) / float(m_defLen))));

			buffer[i * 2U + 0U] *= ampl;
			buffer[i * 2U + 1U] *= ampl;
		}

		m_lastKey = key;
		return;
	}

	// The end of a tone, so we transmit just enough to shape it, and then silence
	for (unsigned int j = 0; j < m_defLen; j++) {
		float ampl = 0.5F * (1.0F - ::cos(M_PI + M_PI * (float(j) / float(m_defLen))));

		buffer[j * 2U + 0U] *= ampl;
		buffer[j * 2U + 1U] *= ampl;
	}

	if (m_defLen < blockSize)
		::memset(buffer + m_defLen * 2U, 0x00, (blockSize - m_defLen) * 2U * sizeof(float));

	m_lastKey = key;
}
